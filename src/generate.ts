import { Project, VariableDeclarationKind, ScriptTarget, IndentationText, NewLineKind, QuoteKind, SourceFile, SyntaxKind } from 'ts-morph'
import { ParsedDTS, GenerateOpts, EnvEnum, ExportMap } from './types.js'
import { toSafeString, removeImport, removeGenerics, removeQuotes } from './util.js'

const HOST_APIBROKER_IMPORT = '@atek-cloud/api-broker'
const DENO_RPC_IMPORT = 'https://atek.cloud/x/rpc@latest/mod.ts'

const PRELUDE = `
//
// File generated by Atek tsgen
// DO NOT MODIFY
//

`

export function generate (dts: ParsedDTS, schema: object, exportMap: ExportMap, opts?: GenerateOpts) {
  if (opts?.env) {
    if (opts.env !== EnvEnum.DENO_USERLAND && opts.env !== EnvEnum.HOST) {
      throw new Error(`The environment must be "deno-userland" or "host". "${opts.env}" is not valid.`)
    }
  }

  const project = new Project({
    useInMemoryFileSystem: true,
    compilerOptions: {
      target: ScriptTarget.Latest
    },
    manipulationSettings: {
      indentationText: IndentationText.TwoSpaces,
      useTrailingCommas: true,
      // newLineKind: NewLineKind.LineFeed,
      quoteKind: QuoteKind.Single,
      insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: true,
    }
  });

  if (dts.metadata.type === 'api') {
    const clientFile = project.createSourceFile(`${dts.metadata.id}.ts`, PRELUDE)
    generateApiClient(clientFile, dts, schema, exportMap, opts)
    clientFile.saveSync()
    const serverFile = project.createSourceFile(`${dts.metadata.id}.server.ts`, PRELUDE)
    // generateApiServer(serverFile, dts, schema, exportMap, opts)
    serverFile.saveSync()
    return {
      clientFile: project.getFileSystem().readFileSync(`${dts.metadata.id}.ts`),
      serverFile: project.getFileSystem().readFileSync(`${dts.metadata.id}.server.ts`)
    }
  }
  if (dts.metadata.type === 'adb-record') {
    const typeFile = project.createSourceFile(`${dts.metadata.id}.ts`, PRELUDE)
    // TODO const clientFile = project.createSourceFile(`${schema.id}.client.ts`, PRELUDE)
    // jsonSchemaGenerateTypes(toSafeString(schema.title || schema.id), schema.definition, {
    //   sourceFile: typeFile,
    //   topLevel: { isExported: true },
    //   lifted: { isExported: true },
    //   anyType: 'any'
    // })
    return {typeFile}
  }
  throw new Error(`Unknown schema type: ${dts.metadata.type}`)
}

function generateApiClient (clientFile: SourceFile, dts: ParsedDTS, schema: object, exportMap: ExportMap, opts: GenerateOpts) {
  const env = opts?.env || EnvEnum.DENO_USERLAND
  const apiIface = dts.ast.getChildrenOfKind(SyntaxKind.InterfaceDeclaration).find(iface => iface.getDefaultKeyword())

  if (env === EnvEnum.DENO_USERLAND) {
    // import { AtekRpcClient, AtekRpcEmitter } from '...'
    clientFile.addImportDeclaration({
      moduleSpecifier: DENO_RPC_IMPORT,
      namedImports: [{ name: 'AtekRpcClient' }, { name: 'AtekRpcEmitter' }]
    })
  } else if (env === EnvEnum.HOST) {
    // import { ApiBrokerClient, ApiBrokerEmitter } from '...'
    clientFile.addImportDeclaration({
      moduleSpecifier: HOST_APIBROKER_IMPORT,
      namedImports: [{ name: 'ApiBrokerClient' }, { name: 'ApiBrokerEmitter' }]
    })
  }

  // const SCHEMAS = {...}
  clientFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    declarations: [{
      name: 'SCHEMAS',
      initializer: JSON.stringify(schema)
    }]
  })
  // const EXPORT_MAP = {...}
  clientFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    declarations: [{
      name: 'EXPORT_MAP',
      initializer: JSON.stringify(exportMap)
    }]
  })

  // export default class FooClient extends AtekRpcClient implements Foo {
  const clientClassName = `${toSafeString(apiIface.getName() || dts.metadata.title || dts.metadata.id || 'Api')}Client`
  const clientClass = clientFile.addClass({name: clientClassName})
  clientClass.setIsExported(true)
  // clientClass.addImplements(iface.getName())
  if (env === EnvEnum.DENO_USERLAND) {
    clientClass.setExtends('AtekRpcClient')
  } else if (env === EnvEnum.HOST) {
    clientClass.setExtends('ApiBrokerClient')
  }

  // constructor () {
  //   super(SCHEMAS, EXPORT_MAP)
  // }
  const ctor = clientClass.addConstructor()
  ctor.setBodyText(`super(SCHEMAS, EXPORT_MAP)`)

  // async methodName (param1: type1, param2: type2): Promise<returnType> {
  //   return this._rpc("methodName", [param1, param2]) 
  // }
  for (const ifaceMethod of apiIface.getMethods()) {
    const classMethod = clientClass.addMethod({name: ifaceMethod.getName()})

    const paramNames = []
    for (const param of ifaceMethod.getParameters()) {
      paramNames.push(param.getName())
      classMethod.addParameter(param.getStructure())
    }

    if (ifaceMethod.getName() === 'subscribe') {
      classMethod.setReturnType(`${toSafeString(removeImport(ifaceMethod.getReturnType().getText()))}Emitter`)
      classMethod.setBodyText(`return this._subscribe([${paramNames.join(', ')}])`)
    } else  {
      classMethod.setIsAsync(true)
      classMethod.setReturnType(`Promise<${removeImport(removeGenerics(ifaceMethod.getReturnType().getText()))}>`)
      classMethod.setBodyText(`return this._rpc(${JSON.stringify(ifaceMethod.getName())}, [${paramNames.join(', ')}])`)
    }
  }

  for (const emitterName in exportMap.events) {
    const emitterIface = dts.ast.getChildrenOfKind(SyntaxKind.InterfaceDeclaration).find(iface => iface.getName() === emitterName)

    // export class FooEmitter extends AtekRpcEmitter implements Foo {
    const emitterClassName = `${toSafeString(emitterName)}Emitter`
    const emitterClass = clientFile.addClass({name: emitterClassName})
    emitterClass.setIsExported(true)
    if (env === EnvEnum.DENO_USERLAND) {
      emitterClass.setExtends('AtekRpcEmitter')
    } else if (env === EnvEnum.HOST) {
      emitterClass.setExtends('ApiBrokerEmitter')
    }

    // on (name: 'eventname', handler: (evt: {param1: type1, param2: type2...}) => void) {
    //   this._on(name, handler)
    // }
    for (const eventName in exportMap.events[emitterName]) {
      const ifaceMethod = emitterIface.getMethods().find(m => removeQuotes(m.getParameters()[0].getType().getText()) === eventName)
      if (!ifaceMethod) throw new Error(`Failed to find emitter interface signature for ${eventName}`)

      const emitterMethod = emitterClass.addMethod({name: 'on'})
      emitterMethod.addParameter({
        name: 'name',
        type: `"${eventName}"`
      })
      emitterMethod.addParameter({
        name: 'handler',
        type: `(evt: ${removeImport(ifaceMethod.getParameters()[1].getType().getText())}) => void`
      })
      emitterMethod.setBodyText(`this._on(name, handler)`)
    }
  }

  // copy any data-structure interfaces and types other than the main API and emitter definitions
  dts.ast.forEachChild(node => {
    switch (node.getKind()) {
      case SyntaxKind.InterfaceDeclaration: {
        const iface = node.asKind(SyntaxKind.InterfaceDeclaration)
        const name = iface.getName()
        if (name === apiIface.getName() || name in exportMap.events) {
          return
        }
        clientFile.addInterface(iface.getStructure())
        break
      }
      case SyntaxKind.TypeAliasDeclaration:
        clientFile.addTypeAlias(node.asKind(SyntaxKind.TypeAliasDeclaration).getStructure())
        break
      case SyntaxKind.EnumDeclaration:
        clientFile.addEnum(node.asKind(SyntaxKind.EnumDeclaration).getStructure())
        break
    }
  })
}

function generateApiServer (serverFile: SourceFile, dts: ParsedDTS,  schema: object, exportMap: ExportMap, opts: GenerateOpts) {
  const env = opts?.env || EnvEnum.DENO_USERLAND

  if (env === EnvEnum.DENO_USERLAND) {
    serverFile.addImportDeclaration({
      moduleSpecifier: DENO_RPC_IMPORT,
      namedImports: [{ name: 'JsonRpcServer' }, { name: 'JsonRpcServerHandlers' }]
    })
  } else if (env === EnvEnum.HOST) {
    serverFile.addImportDeclaration({
      moduleSpecifier: HOST_APIBROKER_IMPORT,
      namedImports: [{ name: 'ApiBrokerServer' }, { name: 'ApiBrokerServerHandlers' }]
    })
  }

  const serverClassName = `${toSafeString(dts.metadata.title || dts.metadata.id || '')}Server`
  const serverClass = serverFile.addClass({
    name: serverClassName
  })
  if (env === EnvEnum.DENO_USERLAND) {
    serverClass.setExtends('JsonRpcServer')
  } else if (env === EnvEnum.HOST) {
    serverClass.setExtends('ApiBrokerServer')
  }
  serverClass.setIsDefaultExport(true)

  const ctor = serverClass.addConstructor()
  const param = ctor.addParameter({name: 'handlers'})
  if (env === EnvEnum.DENO_USERLAND) {
    param.setType('JsonRpcServerHandlers')
  } else if (env === EnvEnum.HOST) {
    param.setType('ApiBrokerServerHandlers')
  }
  ctor.setBodyText(`super(${JSON.stringify(schema, null, 2)}, handlers)`)
}
